import 'cross-fetch/dist/node-polyfill.js';
import { pb, adminEmail, adminPwd } from '../pocketbase.js';
import {
  CveServiceImplementation,
  GetOneRequest,
  GetOneResponse,
  GetManyRequest,
  GetManyResponse,
  CreateRequest,
  CreateResponse,
  UpdateRequest,
  UpdateResponse,
  DeleteRequest,
  DeleteResponse,
  DeepPartial,
  CveModel,
} from '../../proto/compiled_proto/cve.js';
import { cveFromDb, cvesFromDb, cveToDb } from '../models/cve.js';
import { createChannel, createClient } from 'nice-grpc';
import { authServiceUrl } from './auth.js';
import { AuthClient, AuthDefinition } from '../../proto/compiled_proto/auth.js';
import { ProductDbModel } from '../models/product.js';
import { VendorDbModel } from '../models/vendor.js';

/**
 * Requests JWT validation from auth service.
 * @param jwt JWT to be validated
 * @returns 
 */
async function validateJwt(jwt: string): Promise<boolean> {
  const authChannel = createChannel(authServiceUrl);
  const authClient: AuthClient = createClient(AuthDefinition, authChannel);
  const authResponse = await authClient.validate({ jwt });
  authChannel.close();
  return authResponse.result;
}

/**
 * Implementation of CVE service (gRPC).
 */
export const cveServiceImpl: CveServiceImplementation = {

  async getOne(
    request: GetOneRequest,
  ): Promise<DeepPartial<GetOneResponse>> {
    // validate jwt
    const authed = await validateJwt(request.jwt);
    if(!authed)
      return { cve: {} };

    // authenticate to pocketbase
    await pb.admins.authWithPassword(adminEmail, adminPwd);

    const data = await pb.collection('cve').getOne(request.id);
    const cve = cveFromDb(data);

    const products = await pb.collection('products').getList(1, 10, {
      filter: `cve_id = "${cve.cveId}"`
    });

    const vendors = await pb.collection('vendors').getList(1, 1, {
      filter: `cve_id = "${cve.cveId}"`
    });

    for(const product of products.items) {
      cve.products.push(product.vulnerable_product);
    }

    const vendor: VendorDbModel = vendors.items[0];
    cve.vendor = vendor != null ? vendor.vendor : '';

    return { cve: cve };
  },

  async getMany(
    request: GetManyRequest,
  ): Promise<DeepPartial<GetManyResponse>> {
    // validate jwt
    const authed = await validateJwt(request.jwt);
    if(!authed)
      return { cves: [] };

    // authenticate to pocketbase
    await pb.admins.authWithPassword(adminEmail, adminPwd);
    
    const result = await pb.collection('cve').getList(request.pageOffset, request.pageSize);
    const data: CveModel[] = cvesFromDb(result.items);

    // fetch products and vendors
    let products, vendors;
    let vendor: VendorDbModel;
    let productList: ProductDbModel[]; 
    
    for(const cve of data) {
      products = await pb.collection('products').getList(1, 10, {
        filter: `cve_id = "${cve.cveId}"`
      });

      vendors = await pb.collection('vendors').getList(1, 1, {
        filter: `cve_id = "${cve.cveId}"`
      });

      productList = products.items;
      for(const product of productList) {
        cve.products.push(product.vulnerable_product);
      }
      vendor = vendors.items[0];
      cve.vendor = vendor != null ? vendor.vendor : '';
    }

    return { cves: data };
  },

  async create(
    request: CreateRequest,
  ): Promise<DeepPartial<CreateResponse>> {
    // validate jwt
    const authed = await validateJwt(request.jwt);
    if(!authed)
      return {};

    // authenticate to pocketbase
    await pb.admins.authWithPassword(adminEmail, adminPwd);
    
    // create cve
    const data = cveToDb(request.cve);
    const result = await pb.collection('cve').create(data);
    
    // create vulnerable products
    let product: ProductDbModel;
    for(const p of request.cve.products) {
      product = {
        id: '',
        cve_id: request.cve.cveId,
        vulnerable_product: p,
      };
      await pb.collection('products').create(product);
    }

    // create product vendor
    const vendor: VendorDbModel = {
      id: '',
      cve_id: request.cve.cveId,
      vendor: request.cve.vendor,
    };
    await pb.collection('vendors').create(vendor);

    // product_vendor should also be updated for db integrity, this service doesnt use that table
    
    return { id: result.id };
  },

  async update(
    request: UpdateRequest,
  ): Promise<DeepPartial<UpdateResponse>> {
    // validate jwt
    const authed = await validateJwt(request.jwt);
    if(!authed)
      return { result: false };

    // authenticate to pocketbase
    await pb.admins.authWithPassword(adminEmail, adminPwd);

    // update the cve
    const data = cveToDb(request.cve);
    const result = await pb.collection('cve').update(request.cve.id, data);

    return { result: true };
  },

  async delete(
    request: DeleteRequest,
  ): Promise<DeepPartial<DeleteResponse>> {
    // validate jwt
    const authed = await validateJwt(request.jwt);
    if(!authed)
      return { result: false };

    // authenticate to pocketbase
    await pb.admins.authWithPassword(adminEmail, adminPwd);

    // delete the cve
    const result = await pb.collection('cve').delete(request.id);
    return { result };
  },

};
