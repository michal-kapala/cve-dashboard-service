/* eslint-disable */
import type { CallContext, CallOptions } from "nice-grpc-common";
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "";

/** Model for CVE information. */
export interface CveModel {
  id: string;
  cveId: string;
  accessAuthentication: string;
  accessComplexity: string;
  accessVector: string;
  cvss: number;
  cweCode: number;
  cweName: string;
  impactAvailability: string;
  impactConfidentiality: string;
  impactIntegrity: string;
  modDate: string;
  pubDate: string;
  summary: string;
}

/** GetOne request message. */
export interface GetOneRequest {
  id: string;
  jwt: string;
}

/** GetOne response message. */
export interface GetOneResponse {
  cve: CveModel | undefined;
}

/** GetMany request message. */
export interface GetManyRequest {
  pageSize: number;
  pageOffset: number;
  jwt: string;
}

/** GetMany response message. */
export interface GetManyResponse {
  cves: CveModel[];
}

/** Create request message. */
export interface CreateRequest {
  cve: CveModel | undefined;
  jwt: string;
}

/** Create response message. */
export interface CreateResponse {
  id: string;
}

/** Update request message. */
export interface UpdateRequest {
  cve: CveModel | undefined;
  jwt: string;
}

/** Update response message. */
export interface UpdateResponse {
  result: boolean;
}

/** Delete request message. */
export interface DeleteRequest {
  id: string;
  jwt: string;
}

/** Delete response message. */
export interface DeleteResponse {
  result: boolean;
}

function createBaseCveModel(): CveModel {
  return {
    id: "",
    cveId: "",
    accessAuthentication: "",
    accessComplexity: "",
    accessVector: "",
    cvss: 0,
    cweCode: 0,
    cweName: "",
    impactAvailability: "",
    impactConfidentiality: "",
    impactIntegrity: "",
    modDate: "",
    pubDate: "",
    summary: "",
  };
}

export const CveModel = {
  encode(message: CveModel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.cveId !== "") {
      writer.uint32(18).string(message.cveId);
    }
    if (message.accessAuthentication !== "") {
      writer.uint32(26).string(message.accessAuthentication);
    }
    if (message.accessComplexity !== "") {
      writer.uint32(34).string(message.accessComplexity);
    }
    if (message.accessVector !== "") {
      writer.uint32(42).string(message.accessVector);
    }
    if (message.cvss !== 0) {
      writer.uint32(53).float(message.cvss);
    }
    if (message.cweCode !== 0) {
      writer.uint32(56).uint32(message.cweCode);
    }
    if (message.cweName !== "") {
      writer.uint32(66).string(message.cweName);
    }
    if (message.impactAvailability !== "") {
      writer.uint32(74).string(message.impactAvailability);
    }
    if (message.impactConfidentiality !== "") {
      writer.uint32(82).string(message.impactConfidentiality);
    }
    if (message.impactIntegrity !== "") {
      writer.uint32(90).string(message.impactIntegrity);
    }
    if (message.modDate !== "") {
      writer.uint32(98).string(message.modDate);
    }
    if (message.pubDate !== "") {
      writer.uint32(106).string(message.pubDate);
    }
    if (message.summary !== "") {
      writer.uint32(114).string(message.summary);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CveModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCveModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.cveId = reader.string();
          break;
        case 3:
          message.accessAuthentication = reader.string();
          break;
        case 4:
          message.accessComplexity = reader.string();
          break;
        case 5:
          message.accessVector = reader.string();
          break;
        case 6:
          message.cvss = reader.float();
          break;
        case 7:
          message.cweCode = reader.uint32();
          break;
        case 8:
          message.cweName = reader.string();
          break;
        case 9:
          message.impactAvailability = reader.string();
          break;
        case 10:
          message.impactConfidentiality = reader.string();
          break;
        case 11:
          message.impactIntegrity = reader.string();
          break;
        case 12:
          message.modDate = reader.string();
          break;
        case 13:
          message.pubDate = reader.string();
          break;
        case 14:
          message.summary = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CveModel {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      cveId: isSet(object.cveId) ? String(object.cveId) : "",
      accessAuthentication: isSet(object.accessAuthentication) ? String(object.accessAuthentication) : "",
      accessComplexity: isSet(object.accessComplexity) ? String(object.accessComplexity) : "",
      accessVector: isSet(object.accessVector) ? String(object.accessVector) : "",
      cvss: isSet(object.cvss) ? Number(object.cvss) : 0,
      cweCode: isSet(object.cweCode) ? Number(object.cweCode) : 0,
      cweName: isSet(object.cweName) ? String(object.cweName) : "",
      impactAvailability: isSet(object.impactAvailability) ? String(object.impactAvailability) : "",
      impactConfidentiality: isSet(object.impactConfidentiality) ? String(object.impactConfidentiality) : "",
      impactIntegrity: isSet(object.impactIntegrity) ? String(object.impactIntegrity) : "",
      modDate: isSet(object.modDate) ? String(object.modDate) : "",
      pubDate: isSet(object.pubDate) ? String(object.pubDate) : "",
      summary: isSet(object.summary) ? String(object.summary) : "",
    };
  },

  toJSON(message: CveModel): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.cveId !== undefined && (obj.cveId = message.cveId);
    message.accessAuthentication !== undefined && (obj.accessAuthentication = message.accessAuthentication);
    message.accessComplexity !== undefined && (obj.accessComplexity = message.accessComplexity);
    message.accessVector !== undefined && (obj.accessVector = message.accessVector);
    message.cvss !== undefined && (obj.cvss = message.cvss);
    message.cweCode !== undefined && (obj.cweCode = Math.round(message.cweCode));
    message.cweName !== undefined && (obj.cweName = message.cweName);
    message.impactAvailability !== undefined && (obj.impactAvailability = message.impactAvailability);
    message.impactConfidentiality !== undefined && (obj.impactConfidentiality = message.impactConfidentiality);
    message.impactIntegrity !== undefined && (obj.impactIntegrity = message.impactIntegrity);
    message.modDate !== undefined && (obj.modDate = message.modDate);
    message.pubDate !== undefined && (obj.pubDate = message.pubDate);
    message.summary !== undefined && (obj.summary = message.summary);
    return obj;
  },

  create(base?: DeepPartial<CveModel>): CveModel {
    return CveModel.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CveModel>): CveModel {
    const message = createBaseCveModel();
    message.id = object.id ?? "";
    message.cveId = object.cveId ?? "";
    message.accessAuthentication = object.accessAuthentication ?? "";
    message.accessComplexity = object.accessComplexity ?? "";
    message.accessVector = object.accessVector ?? "";
    message.cvss = object.cvss ?? 0;
    message.cweCode = object.cweCode ?? 0;
    message.cweName = object.cweName ?? "";
    message.impactAvailability = object.impactAvailability ?? "";
    message.impactConfidentiality = object.impactConfidentiality ?? "";
    message.impactIntegrity = object.impactIntegrity ?? "";
    message.modDate = object.modDate ?? "";
    message.pubDate = object.pubDate ?? "";
    message.summary = object.summary ?? "";
    return message;
  },
};

function createBaseGetOneRequest(): GetOneRequest {
  return { id: "", jwt: "" };
}

export const GetOneRequest = {
  encode(message: GetOneRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.jwt !== "") {
      writer.uint32(18).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOneRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.jwt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOneRequest {
    return { id: isSet(object.id) ? String(object.id) : "", jwt: isSet(object.jwt) ? String(object.jwt) : "" };
  },

  toJSON(message: GetOneRequest): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.jwt !== undefined && (obj.jwt = message.jwt);
    return obj;
  },

  create(base?: DeepPartial<GetOneRequest>): GetOneRequest {
    return GetOneRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetOneRequest>): GetOneRequest {
    const message = createBaseGetOneRequest();
    message.id = object.id ?? "";
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function createBaseGetOneResponse(): GetOneResponse {
  return { cve: undefined };
}

export const GetOneResponse = {
  encode(message: GetOneResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cve !== undefined) {
      CveModel.encode(message.cve, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOneResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cve = CveModel.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOneResponse {
    return { cve: isSet(object.cve) ? CveModel.fromJSON(object.cve) : undefined };
  },

  toJSON(message: GetOneResponse): unknown {
    const obj: any = {};
    message.cve !== undefined && (obj.cve = message.cve ? CveModel.toJSON(message.cve) : undefined);
    return obj;
  },

  create(base?: DeepPartial<GetOneResponse>): GetOneResponse {
    return GetOneResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetOneResponse>): GetOneResponse {
    const message = createBaseGetOneResponse();
    message.cve = (object.cve !== undefined && object.cve !== null) ? CveModel.fromPartial(object.cve) : undefined;
    return message;
  },
};

function createBaseGetManyRequest(): GetManyRequest {
  return { pageSize: 0, pageOffset: 0, jwt: "" };
}

export const GetManyRequest = {
  encode(message: GetManyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).uint32(message.pageSize);
    }
    if (message.pageOffset !== 0) {
      writer.uint32(16).uint32(message.pageOffset);
    }
    if (message.jwt !== "") {
      writer.uint32(26).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetManyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetManyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageSize = reader.uint32();
          break;
        case 2:
          message.pageOffset = reader.uint32();
          break;
        case 3:
          message.jwt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetManyRequest {
    return {
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      pageOffset: isSet(object.pageOffset) ? Number(object.pageOffset) : 0,
      jwt: isSet(object.jwt) ? String(object.jwt) : "",
    };
  },

  toJSON(message: GetManyRequest): unknown {
    const obj: any = {};
    message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
    message.pageOffset !== undefined && (obj.pageOffset = Math.round(message.pageOffset));
    message.jwt !== undefined && (obj.jwt = message.jwt);
    return obj;
  },

  create(base?: DeepPartial<GetManyRequest>): GetManyRequest {
    return GetManyRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetManyRequest>): GetManyRequest {
    const message = createBaseGetManyRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageOffset = object.pageOffset ?? 0;
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function createBaseGetManyResponse(): GetManyResponse {
  return { cves: [] };
}

export const GetManyResponse = {
  encode(message: GetManyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cves) {
      CveModel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetManyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetManyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cves.push(CveModel.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetManyResponse {
    return { cves: Array.isArray(object?.cves) ? object.cves.map((e: any) => CveModel.fromJSON(e)) : [] };
  },

  toJSON(message: GetManyResponse): unknown {
    const obj: any = {};
    if (message.cves) {
      obj.cves = message.cves.map((e) => e ? CveModel.toJSON(e) : undefined);
    } else {
      obj.cves = [];
    }
    return obj;
  },

  create(base?: DeepPartial<GetManyResponse>): GetManyResponse {
    return GetManyResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetManyResponse>): GetManyResponse {
    const message = createBaseGetManyResponse();
    message.cves = object.cves?.map((e) => CveModel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateRequest(): CreateRequest {
  return { cve: undefined, jwt: "" };
}

export const CreateRequest = {
  encode(message: CreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cve !== undefined) {
      CveModel.encode(message.cve, writer.uint32(10).fork()).ldelim();
    }
    if (message.jwt !== "") {
      writer.uint32(18).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cve = CveModel.decode(reader, reader.uint32());
          break;
        case 2:
          message.jwt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateRequest {
    return {
      cve: isSet(object.cve) ? CveModel.fromJSON(object.cve) : undefined,
      jwt: isSet(object.jwt) ? String(object.jwt) : "",
    };
  },

  toJSON(message: CreateRequest): unknown {
    const obj: any = {};
    message.cve !== undefined && (obj.cve = message.cve ? CveModel.toJSON(message.cve) : undefined);
    message.jwt !== undefined && (obj.jwt = message.jwt);
    return obj;
  },

  create(base?: DeepPartial<CreateRequest>): CreateRequest {
    return CreateRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CreateRequest>): CreateRequest {
    const message = createBaseCreateRequest();
    message.cve = (object.cve !== undefined && object.cve !== null) ? CveModel.fromPartial(object.cve) : undefined;
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function createBaseCreateResponse(): CreateResponse {
  return { id: "" };
}

export const CreateResponse = {
  encode(message: CreateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateResponse {
    return { id: isSet(object.id) ? String(object.id) : "" };
  },

  toJSON(message: CreateResponse): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  create(base?: DeepPartial<CreateResponse>): CreateResponse {
    return CreateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CreateResponse>): CreateResponse {
    const message = createBaseCreateResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateRequest(): UpdateRequest {
  return { cve: undefined, jwt: "" };
}

export const UpdateRequest = {
  encode(message: UpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cve !== undefined) {
      CveModel.encode(message.cve, writer.uint32(10).fork()).ldelim();
    }
    if (message.jwt !== "") {
      writer.uint32(18).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cve = CveModel.decode(reader, reader.uint32());
          break;
        case 2:
          message.jwt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateRequest {
    return {
      cve: isSet(object.cve) ? CveModel.fromJSON(object.cve) : undefined,
      jwt: isSet(object.jwt) ? String(object.jwt) : "",
    };
  },

  toJSON(message: UpdateRequest): unknown {
    const obj: any = {};
    message.cve !== undefined && (obj.cve = message.cve ? CveModel.toJSON(message.cve) : undefined);
    message.jwt !== undefined && (obj.jwt = message.jwt);
    return obj;
  },

  create(base?: DeepPartial<UpdateRequest>): UpdateRequest {
    return UpdateRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<UpdateRequest>): UpdateRequest {
    const message = createBaseUpdateRequest();
    message.cve = (object.cve !== undefined && object.cve !== null) ? CveModel.fromPartial(object.cve) : undefined;
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function createBaseUpdateResponse(): UpdateResponse {
  return { result: false };
}

export const UpdateResponse = {
  encode(message: UpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateResponse {
    return { result: isSet(object.result) ? Boolean(object.result) : false };
  },

  toJSON(message: UpdateResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    return obj;
  },

  create(base?: DeepPartial<UpdateResponse>): UpdateResponse {
    return UpdateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<UpdateResponse>): UpdateResponse {
    const message = createBaseUpdateResponse();
    message.result = object.result ?? false;
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { id: "", jwt: "" };
}

export const DeleteRequest = {
  encode(message: DeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.jwt !== "") {
      writer.uint32(18).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.jwt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return { id: isSet(object.id) ? String(object.id) : "", jwt: isSet(object.jwt) ? String(object.jwt) : "" };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.jwt !== undefined && (obj.jwt = message.jwt);
    return obj;
  },

  create(base?: DeepPartial<DeleteRequest>): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DeleteRequest>): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.id = object.id ?? "";
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { result: false };
}

export const DeleteResponse = {
  encode(message: DeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result === true) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return { result: isSet(object.result) ? Boolean(object.result) : false };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = message.result);
    return obj;
  },

  create(base?: DeepPartial<DeleteResponse>): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DeleteResponse>): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.result = object.result ?? false;
    return message;
  },
};

/** Authentication service. */
export type CveDefinition = typeof CveDefinition;
export const CveDefinition = {
  name: "Cve",
  fullName: "Cve",
  methods: {
    /** Authentication request for a user. */
    getOne: {
      name: "GetOne",
      requestType: GetOneRequest,
      requestStream: false,
      responseType: GetOneResponse,
      responseStream: false,
      options: {},
    },
    /** Returns all CVEs */
    getMany: {
      name: "GetMany",
      requestType: GetManyRequest,
      requestStream: false,
      responseType: GetManyResponse,
      responseStream: false,
      options: {},
    },
    /** Creates a single CVE. */
    create: {
      name: "Create",
      requestType: CreateRequest,
      requestStream: false,
      responseType: CreateResponse,
      responseStream: false,
      options: {},
    },
    /** Updates a single CVE. */
    update: {
      name: "Update",
      requestType: UpdateRequest,
      requestStream: false,
      responseType: UpdateResponse,
      responseStream: false,
      options: {},
    },
    /** Deletes a single CVE. */
    delete: {
      name: "Delete",
      requestType: DeleteRequest,
      requestStream: false,
      responseType: DeleteResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface CveServiceImplementation<CallContextExt = {}> {
  /** Authentication request for a user. */
  getOne(request: GetOneRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetOneResponse>>;
  /** Returns all CVEs */
  getMany(request: GetManyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetManyResponse>>;
  /** Creates a single CVE. */
  create(request: CreateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CreateResponse>>;
  /** Updates a single CVE. */
  update(request: UpdateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<UpdateResponse>>;
  /** Deletes a single CVE. */
  delete(request: DeleteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DeleteResponse>>;
}

export interface CveClient<CallOptionsExt = {}> {
  /** Authentication request for a user. */
  getOne(request: DeepPartial<GetOneRequest>, options?: CallOptions & CallOptionsExt): Promise<GetOneResponse>;
  /** Returns all CVEs */
  getMany(request: DeepPartial<GetManyRequest>, options?: CallOptions & CallOptionsExt): Promise<GetManyResponse>;
  /** Creates a single CVE. */
  create(request: DeepPartial<CreateRequest>, options?: CallOptions & CallOptionsExt): Promise<CreateResponse>;
  /** Updates a single CVE. */
  update(request: DeepPartial<UpdateRequest>, options?: CallOptions & CallOptionsExt): Promise<UpdateResponse>;
  /** Deletes a single CVE. */
  delete(request: DeepPartial<DeleteRequest>, options?: CallOptions & CallOptionsExt): Promise<DeleteResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
